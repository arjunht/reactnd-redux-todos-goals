<html>
	<head>
		<title>My Todos Goals</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
		<script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
		<script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
		<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
	</head>
	<body>
		<!--
		<div>
			<h1>Todo List</h2>
			<input id='todo' type='text' placeholder='Add Todo' />
			<button id='todoBtn'>Add Todo</button>
			<ul id='todos'></ul>
		</div>
		<div>
			<h1>Goals</h1>
			<input id='goal' type='text' placeholder='Add Goal' />
			<button id='goalBtn'>Add Goal</button>
			<ul id='goals'></ul>
		</div>
		
		<hr />
		-->
		
		<div id='app'></div>
		
		<script type='text/javascript'>
			
			function generateId () {
				return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
			}
			
			/* No need of the library code when using Redux
			
			// Library Code
			function createStore (reducer) {
				// The store should have four parts
				// 1. The state
				// 2. Get the state.
				// 3. Listen to changes on the state.
				// 4. Update the state
				
				let state;
				let listeners = [];
				
				const getState = () => state;
				
				const subscribe = (listener) => {
					listeners.push(listener);
					
					return () => {
						listeners = listeners.filter(l => l !== listener)
						// Filter always returns a new array, so it needs to be set back to listeners after filtering out the unsubscribed listener
					}
				}
				
				/* 
					Responsible for updating the state inside of our actual store
					It receives the action which is the specific event that occured within the app
				
				const dispatch = (action) => {
					state = reducer(state, action);
					
					// Loop through all of our listeners (an array of functions) and invoke each one of them
					listeners.forEach((listener) => listener());
				}
				
				// We are returning an object which will have a way to get the state, listen to the changes in state and update the state
				return {
					getState,
					subscribe,
					dispatch
				}
			}
			*/

			// App code

			// Constants are better than strings : We can ensure an error will be thrown for misspelled action types
			const ADD_TODO = 'ADD_TODO';
			const REMOVE_TODO = 'REMOVE_TODO';
			const TOGGLE_TODO = 'TOGGLE_TODO';
			const ADD_GOAL = 'ADD_GOAL';
			const REMOVE_GOAL = 'REMOVE_GOAL';

			/*
				Abstracting all of our different actions into their own functions called Action creators
				Whenever we want to dispatch an action, call our action creators which will return us the specific action
			*/
			function addTodoAction (todo) {
				return {
					type: ADD_TODO,
					todo
				}
			}

			function removeTodoAction (id) {
				return {
					type: REMOVE_TODO,
					id
				}
			}

			function toggleTodoAction (id) {
				return {
					type: TOGGLE_TODO,
					id
				}
			}

			function addGoalAction (goal) {
				return {
					type: ADD_GOAL,
					goal
				}
			}

			function removeGoalAction (id) {
				return {
					type: REMOVE_GOAL,
					id
				}
			}

			function todos (state = [], action) {
				switch (action.type) {
					case ADD_TODO :
						return state.concat([action.todo]);
					case REMOVE_TODO :
						return state.filter((todo) => todo.id !== action.id);
					case TOGGLE_TODO :
						/* 
							If the todos reducer function needs to be a pure function, we cannot directly modify the complete property of the todo object in the state
							Wrong: return state.map((todo) => todo.id === action.id ? todo.complete = !todo.complete : todo)
						*/
						return state.map((todo) => todo.id !== action.id ? todo :
							Object.assign({}, todo, { complete : !todo.complete }))
						/*
							Object.assign allows us to create a new object and merge different properties onto that object 
							So we create a new object {}, then merge all of the properties of the todo object, except for complete which is going to be exact opposite of what complete currently is
						*/
					default :
						return state;
				}	
			}

			function goals (state = [], action) {
				switch (action.type) {
					case ADD_GOAL :
						return state.concat([action.goal]);
					case REMOVE_GOAL :
						return state.filter((goal) => goal.id !== action.id);
					default :
						return state;
				}	
			}

			/* No need of a root reducer when using Redux
			// Root reducer
			function app (state = {}, action) {
				/*
					We are invoking todos here to get the todos portion of our state
					state.todos - todos portion of our state
				
				return {
					todos: todos(state.todos, action),
					goals: goals(state.goals, action)
				}
				/*
					Whenever we want to add new state to our store, add a new property to this object and the value of that property is going to be a reducer function, which is going to be responsbile for managing that slice of our state.
				
			}
			*/
			
			const checker = (store) => (next) => (action) => {
				if(action.type === ADD_TODO &&
					action.todo.name.toLowerCase().includes('bitcoin')) {
					return alert("Bad Todo");
				}
				
				if(action.type === ADD_GOAL &&
					action.goal.name.toLowerCase().includes('bitcoin')) {
					return alert("Bad Goal");
				}
				
				return next(action);
			}
			
			const motivate = (store) => (next) => (action) => {
				if(action.type === ADD_TODO) {
					alert(`Don't forget to ${action.todo.name}!`);
				}

				if(action.type === ADD_GOAL) {
					alert('That\'s a great goal!');
					// alert("That's a great goal!"); - use " and then you don't have to use \
				}

				return next(action)
			}
			
			const logger = (store) => (next) => (action) => {
				console.group(action.type);
					console.log('The action: ', action);
					/*
						We are invoking the next function passing it the the action.
						next is going ot be dispatch
						it's as if we are dispacthing the action here, which will change the state
					*/
					const result = next(action);
					console.log('The new state: ', store.getState());
				console.groupEnd();
				return result;
			}
			
			/* Below ES6
			function checker(store) {
				// next is going to next middleware in line if we have more than one middleware or its going to be dispatch
				return function (next) {
					return function (action) {
						// We have access to store, next and action
						if(action.type === ADD_TODO &&
							action.todo.name.toLowerCase().includes('bitcoin')) {
							return alert("Bad Todo");
						}
						
						if(action.type === ADD_GOAL &&
							action.goal.name.toLowerCase().includes('bitcoin')) {
							return alert("Bad Goal");
						}
						
						return next(action)
					}
				}
			}
			*/
			
			/*
				It doesn't make sense for a library have access to todos function because it could be different for different apps and todos might not be in the same scope
				Therefore we need to pass in the reducer function
				const store = createStore(todos);
			

			// Even though we have two reducer functions - todos and goals - but when we invoke createStore, we need to pass it only a single reducer - thats why we need to use a root reducer - app
			
			*/
			
			const store = Redux.createStore(Redux.combineReducers({
				todos,
				goals
			}), Redux.applyMiddleware(checker, logger, motivate));
			
			/* 
				Whenever we dispacth an action, checker middleware will run before it ever hits the reducer. Then logger middleware will run and then it will hit the reducer.
			*/
			
			/* Commenting all the vanilla JS code
			
			store.subscribe(() => {
				/*
					Is there an other way of doing this by adding only the most recently added todo item
					No, because the subscribe function doesn't have access to that
				
				
				const { todos, goals } = store.getState();
				
				/*
					If i add todo item and click Add Todo - todo list item gets updated
					Then i add goal and click Add goal - goal list gets updated but a duplicate todo list item gets updated too
					
					Reason: DOM list isnt cleared, so we are adding the same todo to a todo already present
					
					Solution: Reset both the unordered list everytime the subsribe function is invoked
				
				
				document.getElementById('todos').innerHTML = ''
				document.getElementById('goals').innerHTML = ''
				
				todos.forEach(addTodoToDOM);
				goals.forEach(addGoalToDOM);
			});
			
			/*
				const unsubscribe = store.subscribe(() => {
					console.log('The new state is', store.getState());
				});

				unsubscribe(); // This doesn't seem to be working becuase of a listeners bug above, fixed

				store.subscribe(() => {
					console.log('The new state after unsubscribe is ', store.getState());
				});
			
			
			// DOM code
			function addTodo () {
				const input = document.getElementById('todo');
				const name = input.value;
				input.value = '';
				
				store.dispatch(addTodoAction({
					id: generateId(),
					name,
					complete: false
				}))
			}
			
			function addGoal () {
				const input = document.getElementById('goal');
				const name = input.value;
				input.value = '';
				
				store.dispatch(addGoalAction({
					id: generateId(),
					name
				}))
			}
			
			/*
				If i use the below in addEventListener in addTodoToDOM function:
				
				node.addEventListener('click', toggleTodo(todo.id));
				
				function toggleTodo (id) {
					store.dispatch(toggleTodoAction(id));
				}
				
				it results in a stack exceeded error, why? TODO
			
			
			document.getElementById('todoBtn')
				.addEventListener('click', addTodo);
			
			document.getElementById('goalBtn')
				.addEventListener('click', addGoal);
			
			function createRemoveButton(onClick) {
				const removeBtn = document.createElement('button');
				
				// Simpler way: removeBtn.innerHTML = 'X'
				const text = document.createTextNode('X');
				removeBtn.appendChild(text);
				
				removeBtn.addEventListener('click', onClick);
				return removeBtn;
			}
			
			function addTodoToDOM (todo) {
				const node = document.createElement('li');
				const text = document.createTextNode(todo.name);
				
				node.appendChild(text);
				node.appendChild(createRemoveButton(() => {
					store.dispatch(removeTodoAction(todo.id))
				}));
				
				// You can't add attributes to text, it has to be an element
				if(todo.complete) {
					node.setAttribute('style','text-decoration:line-through;');
				}
				
				/*
					Simpler way to write it:
					node.style.text-decoration = todo.complete ? 'line-through' : 'none';
				
				
				node.addEventListener('click', () => {
					store.dispatch(toggleTodoAction(todo.id))
				});
				
				document.getElementById('todos')
					.appendChild(node);
			}
			
			function addGoalToDOM (goal) {
				const node = document.createElement('li');
				const text = document.createTextNode(goal.name);
				node.appendChild(text);
				node.appendChild(createRemoveButton(() => {
					store.dispatch(removeGoalAction(goal.id))
				}));
				
				document.getElementById('goals')
					.appendChild(node);
			}
			
			/*
				event.target doesn't work
				
				document.getElementsByTagName('li')
					.addEventListener('click', toggleTodo(event.target.id));
			*/
		</script>
		
		<script type='text/babel'>
			// Stateless Functional Component
			function List(props) {
				return (
					<ul>
						{props.items.map((item) => (
							<li key={item.id}>
								<span
									onClick={() => props.toggle && props.toggle(item.id)}
									style={{textDecoration: item.complete ? 'line-through' : 'none'}}>
									{item.name}
								</span>
								<button onClick={() => props.remove(item)}>
									X
								</button>
							</li>
						))}
					</ul>
				);
			}
			
			/*
				This is going to be an uncontrolled component meaning instead of sticking the value of the input field below on our component state, we will add a ref and then stick this ref on this component instance:
				
				ref={(input) => this.input = input}
				
				Whenever you use a ref, the input field will be passed in as the arg.
				Assign this input field to the instance of the component (this)
				
				
				So whenever we want to grab the value of the input field, we can just grab it from the instance.
				
			*/
			
			class Todos extends React.Component {
				addItem = (e) => {
					e.preventDefault();
					const name = this.input.value;
					this.input.value = ''
					
					this.props.store.dispatch(addTodoAction({
						id: generateId(),
						name,
						complete: false
					}))
				}
				
				removeItem = (todo) => {
					this.props.store.dispatch(removeTodoAction(todo.id))
				}
				
				toggleItem = (id) => {
					this.props.store.dispatch(toggleTodoAction(id))
				}
				
				render() {
					return (
						<div>
							<h1>Todo List</h1>
							<input
								type='text'
								placeholder='Add Todo'
								ref={(input) => this.input = input}
							/>
							<button onClick={this.addItem}>Add Todo</button>
							<List
								items={this.props.todos}
								remove={this.removeItem}
								toggle={this.toggleItem}
							/>
						</div>
					)
				}
			}
			
			class Goals extends React.Component {
				addItem = (e) => {
					e.preventDefault();
					const name = this.input.value;
					this.input.value = ''
					
					this.props.store.dispatch(addGoalAction({
						id: generateId(),
						name
					}))
				}
				
				removeItem = (goal) => {
					this.props.store.dispatch(removeGoalAction(goal.id))
				}
				
				render() {
					return (
						<div>
							<h1>Goals</h1>
							<input
								type='text'
								placeholder='Add Goal'
								ref={(input) => this.input = input}
							/>
							<button onClick={this.addItem}>Add Goal</button>
							
							<List
								items={this.props.goals}
								remove={this.removeItem}
							/>
						</div>
					)
				}
			}
			
			class App extends React.Component {
				
				componentDidMount() {
					/*
						Every component instance has a forceUpdate mehtod on it
						Its rarely used because typically it's an anti-pattern
						When invoked, its going to cause a re-render of that specific component
					*/
					this.props.store.subscribe(() => this.forceUpdate());
				}
				
				render() {
					const { store } = this.props
					const { todos, goals } = store.getState();
					
					return (
						<div>
							<Todos todos={todos} store={store} />
							<Goals goals={goals} store={store} />
						</div>
					);
				}
			}
			
			ReactDOM.render(
				<App store={store} />,
				document.getElementById('app')
			);
		</script>
	</body>
</html>